// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: documents_get.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const findDocumentByID = `-- name: FindDocumentByID :one

SELECT
    d.id, d.file_name, d.title, d.abstract, d.publish_date, d.source, d.to_index, d.s3_file, d.s3_file_preview, d.pdf_link, d.created_at, d.deleted_at, d.to_delete, d.to_generate_preview,
    ARRAY_REMOVE(ARRAY_AGG(DISTINCT a.name), NULL)::text[] AS author_names,
    ARRAY_REMOVE(ARRAY_AGG(DISTINCT r.name), NULL)::text[] AS region_names,
    ARRAY_REMOVE(ARRAY_AGG(DISTINCT k.name), NULL)::text[] AS keyword_names,
    ARRAY_REMOVE(ARRAY_AGG(DISTINCT c.name), NULL)::text[] AS category_names
FROM documents d
LEFT JOIN doc_authors da ON d.id = da.doc_id
LEFT JOIN authors a ON da.author_id = a.id
LEFT JOIN doc_regions dr ON d.id = dr.doc_id
LEFT JOIN regions r ON dr.region_id = r.id
LEFT JOIN doc_keywords dk ON d.id = dk.doc_id
LEFT JOIN keywords k ON dk.keyword_id = k.id
LEFT JOIN doc_categories dc ON d.id = dc.doc_id
LEFT JOIN categories c ON dc.category_id = c.id
WHERE d.id = $1
GROUP BY d.id
`

type FindDocumentByIDRow struct {
	ID                uuid.UUID
	FileName          string
	Title             string
	Abstract          sql.NullString
	PublishDate       sql.NullTime
	Source            sql.NullString
	ToIndex           sql.NullBool
	S3File            string
	S3FilePreview     sql.NullString
	PdfLink           sql.NullString
	CreatedAt         sql.NullTime
	DeletedAt         sql.NullTime
	ToDelete          bool
	ToGeneratePreview sql.NullBool
	AuthorNames       []string
	RegionNames       []string
	KeywordNames      []string
	CategoryNames     []string
}

// Optional: Add an order clause if needed
func (q *Queries) FindDocumentByID(ctx context.Context, id uuid.UUID) (FindDocumentByIDRow, error) {
	row := q.db.QueryRowContext(ctx, findDocumentByID, id)
	var i FindDocumentByIDRow
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.Title,
		&i.Abstract,
		&i.PublishDate,
		&i.Source,
		&i.ToIndex,
		&i.S3File,
		&i.S3FilePreview,
		&i.PdfLink,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.ToDelete,
		&i.ToGeneratePreview,
		pq.Array(&i.AuthorNames),
		pq.Array(&i.RegionNames),
		pq.Array(&i.KeywordNames),
		pq.Array(&i.CategoryNames),
	)
	return i, err
}

const findDocumentByS3Path = `-- name: FindDocumentByS3Path :one
SELECT id, file_name, title, abstract, publish_date, source, to_index, s3_file, s3_file_preview, pdf_link, created_at, deleted_at, to_delete, to_generate_preview
FROM documents
WHERE s3_file = $1
`

func (q *Queries) FindDocumentByS3Path(ctx context.Context, s3File string) (Document, error) {
	row := q.db.QueryRowContext(ctx, findDocumentByS3Path, s3File)
	var i Document
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.Title,
		&i.Abstract,
		&i.PublishDate,
		&i.Source,
		&i.ToIndex,
		&i.S3File,
		&i.S3FilePreview,
		&i.PdfLink,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.ToDelete,
		&i.ToGeneratePreview,
	)
	return i, err
}

const getDocumentsByURIs = `-- name: GetDocumentsByURIs :many
SELECT
    d.id, d.file_name, d.title, d.abstract, d.publish_date, d.source, d.to_index, d.s3_file, d.s3_file_preview, d.pdf_link, d.created_at, d.deleted_at, d.to_delete, d.to_generate_preview,  -- Select all columns from the documents table
    -- Aggregate author names into a text array
    COALESCE(ARRAY_AGG(DISTINCT a.name) FILTER (WHERE a.id IS NOT NULL), '{}'::text[]) AS author_names,
    -- Aggregate region names into a text array
    COALESCE(ARRAY_AGG(DISTINCT r.name) FILTER (WHERE r.id IS NOT NULL), '{}'::text[]) AS region_names,
    -- Aggregate keyword names into a text array
    COALESCE(ARRAY_AGG(DISTINCT k.name) FILTER (WHERE k.id IS NOT NULL), '{}'::text[]) AS keyword_names,
    -- Aggregate category names into a text array
    COALESCE(ARRAY_AGG(DISTINCT c.name) FILTER (WHERE c.id IS NOT NULL), '{}'::text[]) AS category_names
FROM
    documents d
        LEFT JOIN
    doc_authors da ON d.id = da.doc_id
        LEFT JOIN
    authors a ON da.author_id = a.id
        LEFT JOIN
    doc_regions dr ON d.id = dr.doc_id
        LEFT JOIN
    regions r ON dr.region_id = r.id
        LEFT JOIN
    doc_keywords dk ON d.id = dk.doc_id
        LEFT JOIN
    keywords k ON dk.keyword_id = k.id
        LEFT JOIN
    doc_categories dc ON d.id = dc.doc_id
        LEFT JOIN
    categories c ON dc.category_id = c.id
WHERE
    d.s3_file = ANY($1::text[]) -- Filter documents by the provided list of s3_file paths
GROUP BY
    d.id -- Group by document ID to aggregate related names for each document
ORDER BY
    d.id
`

type GetDocumentsByURIsRow struct {
	ID                uuid.UUID
	FileName          string
	Title             string
	Abstract          sql.NullString
	PublishDate       sql.NullTime
	Source            sql.NullString
	ToIndex           sql.NullBool
	S3File            string
	S3FilePreview     sql.NullString
	PdfLink           sql.NullString
	CreatedAt         sql.NullTime
	DeletedAt         sql.NullTime
	ToDelete          bool
	ToGeneratePreview sql.NullBool
	AuthorNames       interface{}
	RegionNames       interface{}
	KeywordNames      interface{}
	CategoryNames     interface{}
}

func (q *Queries) GetDocumentsByURIs(ctx context.Context, dollar_1 []string) ([]GetDocumentsByURIsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDocumentsByURIs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDocumentsByURIsRow
	for rows.Next() {
		var i GetDocumentsByURIsRow
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.Title,
			&i.Abstract,
			&i.PublishDate,
			&i.Source,
			&i.ToIndex,
			&i.S3File,
			&i.S3FilePreview,
			&i.PdfLink,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.ToDelete,
			&i.ToGeneratePreview,
			&i.AuthorNames,
			&i.RegionNames,
			&i.KeywordNames,
			&i.CategoryNames,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDocumentsSorted = `-- name: SearchDocumentsSorted :many
SELECT id, file_name, title, abstract, publish_date, source, to_index, s3_file, s3_file_preview, pdf_link, created_at, deleted_at, to_delete, to_generate_preview
FROM documents
WHERE title     ILIKE '%' || $1 || '%'
   OR file_name ILIKE '%' || $1 || '%'
ORDER BY
    -- sort by file_name?
  CASE WHEN $4 = 'file_name' AND $5 = 'asc'  THEN file_name END  ASC,
  CASE WHEN $4 = 'file_name' AND $5 = 'desc' THEN file_name END DESC,
  -- sort by title?
  CASE WHEN $4 = 'title'     AND $5 = 'asc'  THEN title     END  ASC,
  CASE WHEN $4 = 'title'     AND $5 = 'desc' THEN title     END DESC,
  -- sort by created_at?
  CASE WHEN $4 = 'created_at' AND $5 = 'asc'  THEN created_at END  ASC,
  CASE WHEN $4 = 'created_at' AND $5 = 'desc' THEN created_at END DESC
LIMIT  $2  -- page size
OFFSET $3
`

type SearchDocumentsSortedParams struct {
	Column1 sql.NullString
	Limit   int32
	Offset  int32
	Column4 interface{}
	Column5 interface{}
}

func (q *Queries) SearchDocumentsSorted(ctx context.Context, arg SearchDocumentsSortedParams) ([]Document, error) {
	rows, err := q.db.QueryContext(ctx, searchDocumentsSorted,
		arg.Column1,
		arg.Limit,
		arg.Offset,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Document
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.Title,
			&i.Abstract,
			&i.PublishDate,
			&i.Source,
			&i.ToIndex,
			&i.S3File,
			&i.S3FilePreview,
			&i.PdfLink,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.ToDelete,
			&i.ToGeneratePreview,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
